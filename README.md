# ITMO Laboratory work

Использованные библиотеки:

|Библиотека||
|-----|------|
|**gson**|Для сериализации объектов JSON|
|**org.everit.json.schema**|Для валидации вводимых JSON-данных|

Зависимости в pom.xml:
```xml
    <dependencies>
        <!--FOR JSON VALIDATION-->
        <dependency>
            <groupId>org.everit.json</groupId>
            <artifactId>org.everit.json.schema</artifactId>
            <version>1.3.0</version>
        </dependency>

        <!--JSON PARSER-->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.8.5</version>
        </dependency>
    </dependencies>
```

Задание 5 по лабораторной работе:
```
Разработанная программа должна удовлетворять следующим требованиям:
Класс, коллекцией экземпляров которого управляет программа, должен реализовывать сортировку по умолчанию.
Для хранения необходимо использовать коллекцию типа java.util.ArrayDequeue.
При запуске приложения коллекция должна автоматически заполняться значениями из файла.
Имя файла должно передаваться программе с помощью переменной окружения.
Данные должны храниться в файле в формате csv.
При остановке приложения текущее состояние коллекции должно автоматически сохраняться в файл.
Чтение данных из файла необходимо реализовать с помощью класса java.io.BufferedReader.
Запись данных в файл необходимо реализовать с помощью класса java.io.BufferedWriter.
Все реализованные команды (см. ниже) должны быть задокументированы в формате javadoc.
Формат задания объектов в командах - json.
```
В интерактивном режиме программа должна поддерживать выполнение следующих команд:

* `remove_last`: удалить последний элемент из коллекции
* `remove {element}`: удалить элемент из коллекции по его значению
* `info`: вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)
* `add {element}`: добавить новый элемент в коллекцию
* `add_if_max {element}`: добавить новый элемент в коллекцию, если его значение превышает значение наибольшего элемента этой коллекции
* `show`: вывести в стандартный поток вывода все элементы коллекции в строковом представлении
* `add_if_min {element}`: добавить новый элемент в коллекцию, если его значение меньше, чем у наименьшего элемента этой коллекции

## Сущности коллекций
Для добавления объектов в коллекцию были выбраны несколько типов, наследованные от общего класса Person.

Класс Person - это абстрактный класс дял всех сущностей коллекций.

В нем переопределены **equals** и **hashcode**:
```java
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return height == person.height &&
                name.equals(person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(height, name);
    }
```

Как видно из листинга, класс имеет две значащие поля:
* name - имя объекта
* height - высота объекта

Сортируются элементы в коллекции по их росту:
```java
public int compareTo(Person o) {
        return o.height - height;
    }
```

## Конкретные сущности
Перейдем к конкретным реализациям класса Person. Все классы пока ничем не отличаются, кроме как приветственного сообщения, но это понадобится нам в будушем
### Human
![](https://github.com/AppLoidx/itmo-labwork/blob/master/src/main/resources/assets/menhera.png)

Класс человека
```java
public String helloMessage() {
        return "Hello!";
    }
```
<hr>

### Neko
![](https://github.com/AppLoidx/itmo-labwork/blob/master/src/main/resources/assets/hanekawa.png)

Полу-кошка
```java
public String helloMessage() {
        return "Nyan nyan nyan ni hao nyan!";
    }
```
<hr>

### Tanuki
![](https://github.com/AppLoidx/itmo-labwork/blob/master/src/main/resources/assets/raphtalia.png)

Полу-енот (на самом деле, оборотни)
```java
@Override
    public String helloMessage() {
        return "Hey, hello!";
    }
```

## Начало работы

Так как данные хранятся в csv (Comma-Separated Values), в которой изначально нету какой-либо структуры, кроме запятых, то нужно её
сделать.

Было бы очень не удобно записывать данные в таком виде:
```csv
Human, 170, img/res/assets/img1.png, img/res/assets/img2.png, Cyle
```
Такой вид уже более приемлем:
```csv
class=Neko, name=China, height=140, imgSource=assets/china.png, playable=nyan.mp4
```

Первый способ позволяет легко парсить информацию с файлов, что позволяет не усложнять десериализацию объектов из этого файла. Но он хорош, если с этим файлом всегда будет работать компьютер, то есть изначально оговоренная структура.

Но даже, если это так, то это очень сильно бьет по адаптивности программы. Иначе говоря, мы не сможем изменить структуру нашего проекта без, возможно, больших усилий, которые мы потратим на перепись нескольких модулей проекта

Второй способ позволяет не задавать жесткую структуру и он понятен человеку. Разве что, нам нужно будет написать к нему парсер.

Парсер называется CSVExpressionReader (я не долго думал над именем) и имеет метод `readString` для получения значения определенного поля:

```java
class CSVExpressionReader {
    static String readString(String field, String data){

        // ленивый квантор .+?
        String regex = ",*?[ ]*" + field + "=.*?(,+|$)";

        Pattern p = Pattern.compile(regex);
        Matcher m = p.matcher(data);
        if (m.find()) return m.group().split("=")[1].replace(",", "");

        return null;

    }
}
```

Здесь мы используем регулярное выражение и ленивые кванторы

### Что такое ленивые кванторы?

Дело в том, что метасимволы `*`, `.` и + **жадны**, т.е. обнаруживают максимально, а не минимально возможное совпадение. В итоге обнаружение совпадения почти всегда начинается не с начала, а с конца текста и продолжается в обратном направлении до тех пор, пока совпадение не будет найдено.

В качестве примера рассмотрим строку:
```html
This offer is not available to customers living in <b>AK</b> and <b>HI</b>. 
```
Применив регулярное выражение:
```re
<[Bb]>.*</[Bb]>
```
Мы получим: `<b>AK</b> and <b>HI</b>`

Хотя можно было бы и ожидать два разных выражения в тегах.

И что если жадное совпадение не требуется? В таком случае, можно воспользоваться ленивыми кванторами. Она называются ленивыми потому, что обозначают совпадение с минимальным, а не максимальным количеством символов.

Ленивые кванторы обозначаются с присоединяемым к ним знаком `?`. У каждого жадного квантора имеется свой ленивый эквивалент:
|Жадный квантор|Ленивый квантор|
|--------------|---------------|
|*|\*?|
|+|+?|
|{n,}|{n,}?|

Так, мы можем изменить предыдущее регулярное выражение на:
```re
<[Bb]>.*?</[Bb]>
```
И получить два совпадения: `<b>AK</b>` и `<b>HI</b>`


